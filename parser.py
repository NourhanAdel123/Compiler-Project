# -*- coding: utf-8 -*-
"""parser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wYLwhHs35qr1lXNLwD9ygM_EH4-mB4CK
"""

from collections import deque

def validate_simple_grammar(S, A, non_terminal_symbols):
    """Ensure the grammar is simple."""
    if (not S[0] or not S[1] or not A[0] or not A[1] or  # Check if any rule is empty
        any(symbol[0].isupper() for symbol in [S[0], S[1], A[0], A[1]]) or  # A->aQ
        S[0][0] == S[1][0] or A[0][0] == A[1][0] or  # Check for disjoint symbols
        non_terminal_symbols[0][0] == non_terminal_symbols[1][0]):  # Ensure non-terminal symbols do not clash
        return False
    return True

def update_stack(stack, rule):
    """Pop the stack's top element and push the characters of the rule in reverse order."""
    stack.pop()
    for symbol in reversed(rule):
        stack.append(symbol)

def parse_input(S, A, input_string, non_terminal_symbols):
    """Parse the input string using a recursive descent approach."""
    stack = deque([non_terminal_symbols[0]])  # Start with the initial non-terminal
    index = 0
    print(f"Input String: {list(input_string)}")

    while index < len(input_string):
        current_char = input_string[index]
        if stack:
            top_symbol = stack[-1]

            # Handle the start symbol (S)
            if top_symbol == non_terminal_symbols[0]:
                if current_char == S[0][0]:
                    update_stack(stack, S[0])
                    index -= 1  # Retain current position
                elif current_char == S[1][0]:
                    update_stack(stack, S[1])
                    index -= 1  # Retain current position
                else:
                    print("Your input string is rejected.")
                    return
            # Handle the second non-terminal (B)
            elif top_symbol == non_terminal_symbols[1]:
                if current_char == A[0][0]:
                    update_stack(stack, A[0])
                    index -= 1  # Retain current position
                elif current_char == A[1][0]:
                    update_stack(stack, A[1])
                    index -= 1  # Retain current position
                else:
                    print("Your input string is rejected.")
                    return
            # If the top of the stack matches the current character (terminal)
            elif top_symbol == current_char:
                stack.pop()
            else:
                print("Your input string is rejected.")
                return
        else:
            print("Your input string is rejected.")
            return
        index += 1
        if index >= len(input_string):
            print(f"Stack after checking: {list(stack)}")
            print(f"The remaining unchecked string: {list(input_string[index:])}")

    if not stack:
        print("Your input string is accepted.")
    else:
        print("Your input string is rejected.")

def main():
    while True:
        print("     Simple Grammar Parser")

        # Fixed non-terminal symbols 'S' and 'B'
        non_terminal_symbols = ['S', 'B']

        # User defines the rules for S and B
        S = [input(f"Enter rule 1 for non-terminal 'S':").strip(), input(f"Enter rule 2 for non-terminal 'S':").strip()]
        A = [input(f"Enter rule 1 for non-terminal 'B':").strip(), input(f"Enter rule 2 for non-terminal 'B':").strip()]

        if not validate_simple_grammar(S, A, non_terminal_symbols):
            print(" Grammer is not simple .")
            print(" Try again .")

            continue

        while True:
            print("============================================")
            print("1- Define Another Grammar.")
            print("2- Check Another String.")
            print("3- Exit")
            choice = input("Enter your choice: ").strip()

            if choice == "1":
                break
            elif choice == "2":
                input_string = input("Enter the string to be checked: ").strip()
                parse_input(S, A, input_string, non_terminal_symbols)
            elif choice == "3":
                print("Exiting...")
                return
            else:
                print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()